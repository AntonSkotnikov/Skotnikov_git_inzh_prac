Что такое ветка? Это последовательность коммитов. При создании репозитория автоматически создаётся ветка с именем master (в текущих реалиях - main).

При разработке очень часто возникает необходимость в ветках. В промышленной разработке обычно используются или trunk based, или gitflow политики управления ветками. Рассмотрим упрощенный gitflow.

Cуществует главная ветка, в которой расположена стабильная версия проекта. От неё отходят ветки для разработки фичей или багфиксов. После завершения работы над изменениями эти ветки сливают (мерджат) с главной.
Новую ветку можно создать при помощи команды

git branch <name>
Переключение между ветками делается так:

git checkout <name>
Обратите внимание на то, что переключиться получится только если все локальные изменения закоммичены или их нет (тут кстати может помочь git stash).

Можно удобно создать и переключиться на ветку одной командой:

git checkout -b <name>
Слияние веток
Для слияния нужно переключиться на ветку, в которую мы хотим влить другую (git checkout).

Далее выполняем (вместо <branch> нужно указать имя вливаемой ветки):

git merge <branch> -m "Имя коммита"
Конфликт при слиянии
Иногда при мердже могут возникнуть конфликты. Такое происходит, когда какие то строки в файле менялись в обеих ветках, и гит не может понять, какую версию применить. Команда git merge сообщит об этом. Эти конфликты можно разрешить или вручную в каждом исходнике или через интерактивный интерфейс в vscode.
Rebase ветки
Нужно переключиться на ветку, для которой делаем rebase. Далее указываем ветку, или коммит, на который хотим переместить текущую ветку.

git rebase <branch>
При rebase также могут произойти конфликты. Разрешаются они точно так же, как с merge. Для продолжения и отмены нужно выполнить git rebase --continue и git rebase --abort соответственно.

Подтягивание изменений из удалённого репозитория
Допустим мы работаем с нескольких компьютеров или с коллегой. Тогда в удалённом репозитории будут возникать изменения, которых в нашей локальной версии нет.

Есть команда git fetch. Она скачает все изменения или напишет, что их нет. Однако она не меняет ничего в локальной версии репозитория.

Для того, чтобы применить изменения есть команда git pull. Она применит изменения для текущей ветки. Отметим, что git pull автоматически выполняет git fetch.

Мы упоминали про связывание локальной и удалённой веток между собой когда говорили про git push. Так вот при git pull это оказывается важным. Если ветки не связаны, то гит не будет знать из какой удалённо ветки применять изменения в локальную.

При git pull так же могут возникнуть некоторые конфликты. Здесь несколько вариантов:

git pull --rebase произведёт rebase локальной ветки.
git pull --commit смерджит локальную и удалённую ветки.
Как посмотреть, кто виноват в конкретной строчке кода
Для обнаружения авторства есть команда git blame. Ей можно указать конкретный файл, и она укажет автора каждой строки и каким коммитом она последний раз менялась.
